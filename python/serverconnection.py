from socket import socket
import ssl
import base64
from threading import Thread

#Represents a web server connection
class ServerConnection:
    '''
    Represents a webserver connection.
    The protocol for this is as follows:
    The webserver initiates a connection, and
    requests a secret, random string.

    This string is sent from this actuator server,
    to the other server.
    The webserver encrypts it with its pre-generated private
    key, then sends it back. 
    The actuator server will then attempt to decrypt the
    given encrypted string, and if it decodes to the original
    string, the webserver is verified.

    After this, the webserver can point the actuator server to
    the client, which will trigger a ClientConnection to begin.
    '''
    def __init__(self, socket, verbose):
        self.verbose = verbose
        self.socket = socket
        self.state = 'WAITING'
        self.client_secret = ''

    def listen(port, keyfile, certfile, ca_cert, verbose):
        '''
        Listens on the given port for a new connection.
        '''
        try:
            sock = socket()
            ssl_sock = ssl.wrap_socket(sock, cert_reqs = ssl.CERT_REQUIRED, server_side = True, keyfile = keyfile, certfile = certfile, ca_certs = ca_cert)
            
            ssl_sock.bind((ssl_sock.getsockname()[0], port))
            ssl_sock.listen(0)

            connection = ssl_sock.accept()[0]

            if verbose:
                print('Accepted a connection from ' + connection.getpeername()[0])

            #Stop listening on the given port
            ssl_sock.close()
        except ssl.SSLError as err:
            print("Underlying SSL error occured. " + err.strerror)
            return None
        except ssl.CertificateError as err:
            #should never be hit, certificates currently aren't needed.
            print("Error while trying to validate the server's certificate. " + err.strerror)
            return None
        except Exception as err:
            print("Some exception occured when attempting to listen for a connection!")
            print(err)
            return None

        return ServerConnection(connection, verbose)
    
    def nextExchange(self):

        message = ''
        #We use ascii, then convert to utf-8, simply so we don;t
        #need to worry about multi-byte characters when decoding.
        while len(message) < 1 or message[-1] != '\0':
            message += self.socket.recv().decode('ascii')

        message = message.encode().decode('utf-8')[0:-1]
        
        if self.verbose:
            print('Received message "' + message + '"')

        if self.state == 'WAITING':
            #Waiting for ready signeal
            if message.upper() == 'READY':
                self.socket.sendall('OK\0'.encode())
                self.state = 'RECEIVING_INFO'
            elif message.upper() == 'STATUS':
                self.socket.sendall('FREE\0'.encode())
            else:
                self.socket.close()
                return False

        elif self.state == 'RECEIVING_INFO':
            #Receiving info about the client.
            #The info will be the clients IP,
            #as well as a (cryptographically secure)
            #secret generated by the webserver.
            #This will be a single message, seperated
            #by a newline character.
            #Also, the secret will be base64 encoded,
            #So that a zero byte isn't accidentily included
            parts = message.split(sep = '\n')
            if len(parts) != 2:
                print('Received malformed message: {}'.format(message))
                print('Closing connection due to malformed message')
                self.socket.close()
                return False
            
            ip = parts[0] #ip in xxx.xxx.xxx.xxx format
            self.client_secret = base64.b64decode(parts[1].encode()).hex() #secret shared between client and both servers
            #Now, we attempt to connect to the given client.
            #To do this, we use a websocket. This requires a
            #certificate from an actual CA (can't be self signed).

            #TODO maybe do this using let's encrypt? We could also
            #have it auto-renew, as well as having the webserver verified.

            

        elif self.state == 'WITH_CLIENT':
            if message == 'STATUS':
                #Get the status of the actuator server (busy, in this case) 
                self.socket.sendall('BUSY\0'.encode())
            elif message == 'TIMEOUT':
                #TODO
                #The webserver is telling this server to break it's connection
                #with the client. Send back OK when done.
                self.state = 'WAITING'
                self.socket.sendall('OK\0'.encode())

class WebserverListenerThread(Thread):
    def __init__(self, port, keyfile, certfile, ca_certfile, verbose):
        Thread.__init__(self)
        self.port = port
        self.keyfile = keyfile
        self.certfile = certfile
        self.ca_certfile = ca_certfile
        self.verbose = verbose
        self.should_die = False
        self.has_error = False
        self.err_msg = ''
    
    def run(self):
        while not self.should_die:
            conn = ServerConnection.listen(self.port, self.keyfile, self.certfile, self.ca_certfile, self.verbose)
            while not self.should_die:
                exchange_result = conn.nextExchange()
                if exchange_result == False:
                    break
                #TODO check if it's a ClientConnection, then spawn a client thread

    def kill(self):
        self.should_die = True

    def haserror(self):
        return self.has_error
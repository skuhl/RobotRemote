from socket import socket
import ssl
import base64
import asyncio
from threading import Thread
from clientconnection import ClientConnection

class ServerProtocol(asyncio.Protocol):
    '''
    Protocol for communicating with the webserver.
    '''
    def __init__(self, secure_context, pressed_lock, pressed_data, verbose):
        self.verbose = verbose
        self.state = 'WAITING'
        self.secure_context = secure_context
        self.pressed_lock = pressed_lock
        self.pressed_data = pressed_data

    def connection_made(self, transport):
        self.transport = transport
        self.state = 'WAITING'
        self.message = ''

        print(transport)

    def connection_lost(self, exc):
        if exc == None:
            return
        #Possibly do more stuff here?
        raise exc

    def data_received(self, data):
        self.message += data.decode('ascii')

        if self.message[-1] != '\0':
            return

        self.message = self.message.encode().decode('utf-8')[0:-1]
        
        if self.verbose:
            print('Received message "' +self.message + '"')

        if self.state == 'WAITING':
            #Waiting for ready signal
            if self.message.upper() == 'READY':
                self.transport.write('OK\0'.encode())
                self.state = 'RECEIVING_SECRET'
            elif self.message.upper() == 'STATUS':
                self.transport.write('FREE\0'.encode())
            else:
                self.transport.close()
                return False

        elif self.state == 'RECEIVING_SECRET':
            #Receiving info about the client.
            #The info will be a (cryptographically secure)
            #secret generated by the webserver.
            #This will be a single message, seperated
            #by a newline character.
            #Also, the secret will be base64 encoded,
            #So that a zero byte isn't accidentily included

            client_secret = base64.b64decode(self.message.encode()).hex() #secret shared between client and both servers
            
            self.transport.write('OK\0'.encode())

            #Now, we attempt to connect to the given client.
            #To do this, we use a websocket. This requires a
            #certificate from an actual CA (can't be self signed).
            ##self.client_conn = ClientConnection.do_websock(self.socket.getsockname()[0], 5001, client_secret, self.cert, self.key, self.ca, self.pressed_lock, self.pressed_data, self)

        elif self.state == 'WITH_CLIENT':
            if self.message.upper() == 'STATUS':
                #Get the status of the actuator server (busy, in this case) 
                self.transport.write('BUSY\0'.encode())
            elif self.message.upper() == 'TIMEOUT':
                self.client_conn.kill()
                self.state = 'WAITING'
                self.transport.write('OK\0'.encode())
        else:
            #TODO RAISE AN EXCEPTION
            self.transport.close()

        self.message = ''

    def eof_received(self):
        #returning false means just close the connection
        #Doesn't really matter, SSL connections can't be half-closed
        print('EOF received')
        return False

from socket import socket
import ssl
import base64
import asyncio
from threading import Thread
from websocket_server import WebSocketConnectionInfo
from asyncio import Queue

class ServerProtocol(asyncio.Protocol):
    '''
    Protocol for communicating with the webserver.
    '''
    def __init__(self, loop, accepting_websocks_sem, secure_context, pressed_lock, pressed_data, verbose):
        self.verbose = verbose
        self.loop = loop
        self.state = 'WAITING'
        self.secure_context = secure_context
        self.pressed_data_lock = pressed_lock
        self.pressed_data = pressed_data
        self.client_comm_queue = Queue()
        self.accepting_websocks_sem = accepting_websocks_sem
        self.websock_connected = asyncio.Event()
        loop.create_task(self.check_other_comms())

    def connection_made(self, transport):
        self.transport = transport
        self.state = 'WAITING'
        self.message = ''

    def connection_lost(self, exc):
        if exc == None:
            return
        #Possibly do more stuff here?
        raise exc

    def data_received(self, data):
        self.message += data.decode('ascii')

        if self.message[-1] != '\0':
            return

        self.message = self.message.encode().decode('utf-8')[0:-1]
        
        if self.verbose:
            print('Received message "' + self.message + '"')

        if self.state == 'WAITING':
            #Waiting for ready signal
            if self.message.upper() == 'READY':
                self.transport.write('OK\0'.encode())
                self.state = 'RECEIVING_SECRET'
            elif self.message.upper() == 'STATUS':
                self.transport.write('FREE\0'.encode())
            else:
                self.transport.close()
                return False

        elif self.state == 'RECEIVING_SECRET':
            #Receiving info about the client.
            #The info will be a (cryptographically secure)
            #secret generated by the webserver.
            #This will be a single message, seperated
            #by a newline character.
            #Also, the secret will be base64 encoded,
            #So that a zero byte isn't accidentily included

            client_secret = self.message #secret shared between client and both servers

            #Now, we attempt to connect to the given client.
            #To do this, we use a websocket. This requires a
            #certificate from an actual CA (can't be self signed).
            self.websock_connected.clear()
            self.accepting_websocks_sem.release()
            
            WebSocketConnectionInfo(self.websock_connected, client_secret, self.client_comm_queue)
            
            #Tell webserver we are ready for connections
            self.transport.write('OK\0'.encode())

            #wait for connection
            self.loop.create_task(self.websock_timeout(5))

        elif self.state == 'WITH_CLIENT':
            if self.message.upper() == 'STATUS':
                #Get the status of the actuator server (busy, in this case) 
                self.transport.write('BUSY\0'.encode())
            elif self.message.upper() == 'TIMEOUT':
                self.state = 'WAITING'
                self.transport.write('OK\0'.encode())
        else:
            #TODO RAISE AN EXCEPTION
            self.transport.close()

        self.message = ''

    def eof_received(self):
        #returning false means just close the connection
        #Doesn't really matter, SSL connections can't be half-closed
        print('EOF received')
        return False

    async def check_other_comms(self):
        #TODO change queue to event.
        #store in WebSocketConnectionInfo.
        while True:
            msg = await self.client_comm_queue.get()
            if msg == 'done':
                #tell server
                print('Client left websocket.')
                self.websock_connected.clear()
                self.state = 'WAITING'
                self.transport.write('FREE\0'.encode())

    async def websock_timeout(self, timeout):
        try:
            await asyncio.wait_for(self.websock_connected.wait(), timeout)
        except asyncio.TimeoutError:
            #ERROR, websocket didn't connect fast enough!
            self.websock_connected.clear()
            self.state = 'WAITING'
            self.transport.write('CONNECTION_ERROR\0'.encode())
        else:
            #websocket connected
            self.transport.write('CONNECTED\0'.encode())

